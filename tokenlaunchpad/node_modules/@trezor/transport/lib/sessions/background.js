"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsBackground = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@trezor/utils");
const utils_2 = require("@trezor/utils");
const ERRORS = tslib_1.__importStar(require("../errors"));
const lockDuration = 1000 * 4;
class SessionsBackground extends utils_2.TypedEmitter {
    constructor({ signal }) {
        super();
        this.descriptors = {};
        this.locksQueue = [];
        this.locksTimeoutQueue = [];
        this.lastSessionId = 0;
        signal.addEventListener('abort', () => {
            this.locksQueue.forEach(lock => clearTimeout(lock.id));
        });
    }
    handleMessage(message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                switch (message.type) {
                    case 'handshake':
                        result = this.handshake();
                        break;
                    case 'enumerateIntent':
                        yield this.enumerateIntent();
                        break;
                    case 'enumerateDone':
                        result = yield this.enumerateDone(message.payload);
                        break;
                    case 'acquireIntent':
                        result = yield this.acquireIntent(message.payload);
                        break;
                    case 'acquireDone':
                        result = yield this.acquireDone(message.payload);
                        break;
                    case 'getSessions':
                        result = yield this.getSessions();
                        break;
                    case 'releaseIntent':
                        result = yield this.releaseIntent(message.payload);
                        break;
                    case 'releaseDone':
                        result = yield this.releaseDone(message.payload);
                        break;
                    case 'getPathBySession':
                        result = this.getPathBySession(message.payload);
                        break;
                    case 'dispose':
                        this.dispose();
                        break;
                    default:
                        throw new Error(ERRORS.UNEXPECTED_ERROR);
                }
                result = JSON.parse(JSON.stringify(Object.assign(Object.assign({}, result), { id: message.id })));
                return result;
            }
            catch (err) {
                return Object.assign(Object.assign({}, this.error(ERRORS.UNEXPECTED_ERROR)), { id: message.type });
            }
            finally {
                if (result && result.success && result.payload && 'descriptors' in result.payload) {
                    const { descriptors } = result.payload;
                    setTimeout(() => this.emit('descriptors', Object.values(descriptors)), 0);
                }
            }
        });
    }
    handshake() {
        return this.success(undefined);
    }
    enumerateIntent() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.waitInQueue();
            return this.success(undefined);
        });
    }
    enumerateDone(payload) {
        this.clearLock();
        const disconnectedDevices = this.filterDisconnectedDevices(Object.values(this.descriptors), payload.descriptors.map(d => d.path));
        disconnectedDevices.forEach(d => {
            delete this.descriptors[d.path];
        });
        payload.descriptors.forEach(d => {
            if (!this.descriptors[d.path]) {
                this.descriptors[d.path] = Object.assign(Object.assign({}, d), { session: null });
            }
        });
        return Promise.resolve(this.success({
            descriptors: Object.values(this.descriptors),
        }));
    }
    acquireIntent(payload) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const previous = (_a = this.descriptors[payload.path]) === null || _a === void 0 ? void 0 : _a.session;
            if (payload.previous && payload.previous !== previous) {
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            if (!this.descriptors[payload.path]) {
                return this.error(ERRORS.DESCRIPTOR_NOT_FOUND);
            }
            yield this.waitInQueue();
            if (previous !== ((_b = this.descriptors[payload.path]) === null || _b === void 0 ? void 0 : _b.session)) {
                this.clearLock();
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            const unconfirmedSessions = JSON.parse(JSON.stringify(this.descriptors));
            this.lastSessionId++;
            unconfirmedSessions[payload.path].session = `${this.lastSessionId}`;
            return this.success({
                session: unconfirmedSessions[payload.path].session,
                descriptors: Object.values(unconfirmedSessions),
            });
        });
    }
    acquireDone(payload) {
        this.clearLock();
        if (!this.descriptors[payload.path]) {
            return this.error(ERRORS.DESCRIPTOR_NOT_FOUND);
        }
        this.descriptors[payload.path].session = `${this.lastSessionId}`;
        return Promise.resolve(this.success({
            descriptors: Object.values(this.descriptors),
        }));
    }
    releaseIntent(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const path = this.getPathFromSessions({ session: payload.session });
            if (!path) {
                return this.error(ERRORS.SESSION_NOT_FOUND);
            }
            yield this.waitInQueue();
            return this.success({ path });
        });
    }
    releaseDone(payload) {
        this.descriptors[payload.path].session = null;
        this.clearLock();
        return Promise.resolve(this.success({ descriptors: Object.values(this.descriptors) }));
    }
    getSessions() {
        return Promise.resolve(this.success({ descriptors: Object.values(this.descriptors) }));
    }
    getPathBySession({ session }) {
        const path = this.getPathFromSessions({ session });
        if (!path) {
            return this.error(ERRORS.SESSION_NOT_FOUND);
        }
        return this.success({ path });
    }
    getPathFromSessions({ session }) {
        let path;
        Object.keys(this.descriptors).forEach(pathKey => {
            var _a;
            if (((_a = this.descriptors[pathKey]) === null || _a === void 0 ? void 0 : _a.session) === session) {
                path = pathKey;
            }
        });
        return path;
    }
    startLock() {
        const dfd = (0, utils_1.createDeferred)();
        const timeout = setTimeout(() => {
            dfd.resolve(undefined);
        }, lockDuration);
        this.locksQueue.push({ id: timeout, dfd });
        this.locksTimeoutQueue.push(timeout);
        return this.locksQueue.length - 1;
    }
    clearLock() {
        const lock = this.locksQueue[0];
        if (lock) {
            this.locksQueue[0].dfd.resolve(undefined);
            this.locksQueue.shift();
            clearTimeout(this.locksTimeoutQueue[0]);
            this.locksTimeoutQueue.shift();
        }
    }
    waitForUnlocked(myIndex) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (myIndex > 0) {
                const beforeMe = this.locksQueue.slice(0, myIndex);
                if (beforeMe.length) {
                    yield Promise.all(beforeMe.map(lock => lock.dfd.promise));
                }
            }
        });
    }
    waitInQueue() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const myIndex = this.startLock();
            yield this.waitForUnlocked(myIndex);
        });
    }
    filterDisconnectedDevices(prevDevices, paths) {
        return prevDevices.filter(d => !paths.find(p => d.path === p));
    }
    success(payload) {
        return {
            success: true,
            payload,
        };
    }
    error(error) {
        return {
            success: false,
            error,
        };
    }
    dispose() {
        this.locksQueue.forEach(lock => clearTimeout(lock.id));
        this.locksTimeoutQueue.forEach(timeout => clearTimeout(timeout));
        this.descriptors = {};
        this.lastSessionId = 0;
    }
}
exports.SessionsBackground = SessionsBackground;
//# sourceMappingURL=background.js.map