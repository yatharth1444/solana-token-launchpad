"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.receiveAndParse = exports.receive = void 0;
const tslib_1 = require("tslib");
const protobuf_1 = require("@trezor/protobuf");
function receiveRest(result, receiver, offset, expectedLength, chunkHeader) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (offset >= expectedLength) {
            return;
        }
        const data = yield receiver();
        if (data == null) {
            throw new Error('Received no data.');
        }
        const length = offset + data.byteLength - chunkHeader.byteLength;
        Buffer.from(data).copy(result, offset, chunkHeader.byteLength, length);
        return receiveRest(result, receiver, length, expectedLength, chunkHeader);
    });
}
function receive(receiver, protocol) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const data = yield receiver();
        const { length, messageType, payload } = protocol.decode(data);
        const result = Buffer.alloc(length);
        const chunkHeader = protocol.getChunkHeader(Buffer.from(data));
        if (length) {
            payload.copy(result);
        }
        yield receiveRest(result, receiver, payload.length, length, chunkHeader);
        return { messageType, payload: result };
    });
}
exports.receive = receive;
function receiveAndParse(messages, receiver, protocol) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { messageType, payload } = yield receive(receiver, protocol);
        const { Message, messageName } = (0, protobuf_1.createMessageFromType)(messages, messageType);
        const message = (0, protobuf_1.decode)(Message, payload);
        return {
            message,
            type: messageName,
        };
    });
}
exports.receiveAndParse = receiveAndParse;
//# sourceMappingURL=receive.js.map