import { Deferred, TypedEmitter } from '@trezor/utils';
import { Session } from '@trezor/transport';
import { TransportProtocol } from '@trezor/protocol';
import { DeviceCommands, PassphrasePromptResponse } from './DeviceCommands';
import { PROTO, NETWORK } from '../constants';
import { DEVICE, DeviceButtonRequestPayload } from '../events';
import { type Transport, type Descriptor } from '@trezor/transport';
import { Device as DeviceTyped, DeviceFirmwareStatus, Features, ReleaseInfo, UnavailableCapabilities, FirmwareType, VersionArray, KnownDevice } from '../types';
export type RunOptions = {
    skipFinalReload?: boolean;
    waiting?: boolean;
    onlyOneActivity?: boolean;
    cancelPopupRequest?: () => any;
    keepSession?: boolean;
    useCardanoDerivation?: boolean;
};
export declare const GET_FEATURES_TIMEOUT = 3000;
export declare const GET_FEATURES_TIMEOUT_REACT_NATIVE = 20000;
export interface DeviceEvents {
    [DEVICE.PIN]: (device: Device, b: PROTO.PinMatrixRequestType | undefined, callback: (err: any, pin: string) => void) => void;
    [DEVICE.WORD]: (device: Device, b: PROTO.WordRequestType, callback: (err: any, word: string) => void) => void;
    [DEVICE.PASSPHRASE]: (device: Device, callback: (response: PassphrasePromptResponse) => void) => void;
    [DEVICE.PASSPHRASE_ON_DEVICE]: () => void;
    [DEVICE.BUTTON]: (device: Device, payload: DeviceButtonRequestPayload) => void;
    [DEVICE.ACQUIRED]: () => void;
    [DEVICE.SAVE_STATE]: (state: string) => void;
}
export declare class Device extends TypedEmitter<DeviceEvents> {
    transport: Transport;
    protocol: TransportProtocol;
    originalDescriptor: Descriptor;
    unreadableError?: string;
    firmwareStatus: DeviceFirmwareStatus;
    firmwareRelease?: ReleaseInfo | null;
    features: Features;
    featuresNeedsReload: boolean;
    acquirePromise?: ReturnType<Transport['acquire']>;
    releasePromise?: ReturnType<Transport['release']>;
    runPromise?: Deferred<void>;
    loaded: boolean;
    inconsistent: boolean;
    firstRunPromise: Deferred<boolean>;
    activitySessionID?: Session | null;
    commands?: DeviceCommands;
    keepSession: boolean;
    instance: number;
    internalState: string[];
    externalState: string[];
    unavailableCapabilities: UnavailableCapabilities;
    networkTypeState: NETWORK.NetworkType[];
    firmwareType?: FirmwareType;
    name: string;
    color?: string;
    availableTranslations: string[];
    authenticityChecks: NonNullable<KnownDevice['authenticityChecks']>;
    constructor(transport: Transport, descriptor: Descriptor);
    static fromDescriptor(transport: Transport, originalDescriptor: Descriptor): Device;
    static createUnacquired(transport: Transport, descriptor: Descriptor, unreadableError?: string): Device;
    acquire(): Promise<void>;
    release(): Promise<void>;
    cleanup(): Promise<void>;
    run(fn?: () => Promise<void>, options?: RunOptions): Promise<void>;
    override(error: Error): Promise<void>;
    interruptionFromUser(error: Error): Promise<void>;
    interruptionFromOutside(): void;
    _runInner<X>(fn: (() => Promise<X>) | undefined, options: RunOptions): Promise<void>;
    getCommands(): DeviceCommands;
    setInstance(instance?: number): void;
    getInstance(): number;
    setInternalState(state?: string): void;
    getInternalState(): string;
    setExternalState(state?: string): void;
    getExternalState(): string;
    validateState(preauthorized?: boolean): Promise<string | undefined>;
    initialize(useCardanoDerivation: boolean): Promise<void>;
    getFeatures(): Promise<void>;
    checkFirmwareRevision(): Promise<void>;
    changeLanguage({ language, binary, }: {
        language?: undefined;
        binary: ArrayBuffer;
    } | {
        language: string;
        binary?: undefined;
    }): Promise<{
        message: string;
    }>;
    private _uploadTranslationData;
    _updateFeatures(feat: Features): void;
    isUnacquired(): boolean;
    disconnect(): void;
    isBootloader(): boolean;
    isInitialized(): boolean;
    isSeedless(): boolean;
    isInconsistent(): boolean;
    getVersion(): VersionArray | [];
    atLeast(versions: string[] | string): boolean;
    isUsed(): boolean;
    isUsedHere(): boolean;
    isUsedElsewhere(): boolean;
    isRunning(): boolean;
    isLoaded(): boolean;
    waitForFirstRun(): Promise<boolean>;
    getDevicePath(): string;
    isT1(): boolean;
    hasUnexpectedMode(allow: string[], require: string[]): "ui-device_bootloader_mode" | "ui-device_not_in_bootloader_mode" | "ui-device_not_initialized" | "ui-device_seedless" | null;
    dispose(): Promise<import("@trezor/transport/lib/types").AbortableCall<void, "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "wrong previous session" | "session not found"> | undefined>;
    getMode(): "normal" | "bootloader" | "initialize" | "seedless";
    toMessageObject(): DeviceTyped;
    legacyForceRelease(): Promise<void>;
}
//# sourceMappingURL=Device.d.ts.map